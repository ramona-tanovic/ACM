# load library
library(tidyverse)

# setup
trials <- 100
rate <- .7
self <- rep(NA, trials)
other <- rep(NA, trials)
self[1] <- agent_random(.5) # Initial choice for self
for (t in seq(trials)){other[t] <- agent_random(rate)} # Initial choice for other

# First strategy
# WSLS
# win-stay-lose-shift
# 1. If the player wins, they will repeat the same choice in the next round.
# 2. If the player loses, they will switch to a different choice in the next round.
# Probalistic is easier, but the deterministic is more effective in the long run, especially when it is applied to the real data.

agent_WSLS <- function(prevChoice, feedback) {
  if (feedback == 1) {
    choice = prevChoice # Stay with the same choice
  } else if (feedback == 0) {
    return(1 - prevChoice) # Switch to the other choice
  }
  return(choice)}

choice_WSLS <- agent_WSLS(1, 0) # Example usage: previous choice was 1 and feedback was 0 (loss), so the agent will switch to 0.

for (i in 2:trials) {
  if (self[i-1] == other[i-1]) {
    feedback = 1 } 
  else {feedback = 0}
  self[i] <- agent_WSLS(self[i-1], feedback)}
# Update self's choice based on WSLS strategy

# Second strategy
# Heuristic
# The penny is in one hand for 10 turns and then it switches. The opponent can learn this pattern and exploit it, but it can also be effective if the opponent is not paying attention or if the game is short and the opponent is not able to learn the pattern quickly. It can be a good strategy for a player who wants to keep their opponent guessing and create uncertainty in the game. However, it may not be the best strategy for a player who wants to maximize their chances of winning in the long run, as it can be easily exploited by an opponent who is paying attention.

agent_heuristic <- function(turn) {
  if (turn %% 20 < 10) {
    return(1) # Choose hand 1 for the first 10 turns
  } else {
    return(0) # Switch to hand 0 for the next 10 turns
  }
}

for (i in seq(trials)) {
  other[i] <- agent_heuristic(i) # Update otherâ€™s choice based on the heuristic strategy
}

# memory

