# R/fit_policy.R
# -----------------------------------------------------------------------------
# Generate sequences and fit the interpretable WSLS policy model in Stan.
#
# Why do this?
# Even if a strategy is not literally WSLS, fitting a simple WSLS policy model
# gives an interpretable "signature":
# - are actions consistent with win-stay / lose-shift?
# - how noisy/random (lapse) does the behavior look?
#
# Note:
# This file expects prior hyperparameters defined in R/config.R:
# PRIOR_RANDOM, PRIOR_WSLS, PRIOR_KTOM
# -----------------------------------------------------------------------------

generate_policy_fit_data <- function(strategyA, S, T, priors, k = 2, seed = 123) {

  # Choose the correct prior model + hyperparameters for strategyA
  if (strategyA == "WSLS") {
    stanA <- priors$wsls
    dataA <- PRIOR_WSLS
  } else if (strategyA == "kToM") {
    stanA <- priors$ktom
    dataA <- PRIOR_KTOM
  } else if (strategyA == "StanRandom") {
    stanA <- priors$random
    dataA <- PRIOR_RANDOM
  } else {
    stop("Unknown strategy for policy-fit data: ", strategyA)
  }

  paramsA <- sample_prior_fixed_param(stanA, n_draws = S, data = dataA, seed = seed + 10)
  paramsB <- sample_prior_fixed_param(priors$random, n_draws = S, data = PRIOR_RANDOM, seed = seed + 20)

  N <- S * T
  a <- integer(N)
  b <- integer(N)
  roleA <- integer(N)
  start_idx <- integer(S)

  pos <- 1L
  for (s in seq_len(S)) {
    start_idx[s] <- pos

    agentA <- make_agent(strategyA, paramsA[s, ], k = k)
    agentB <- make_agent("StanRandom", paramsB[s, ], k = k)

    sim <- simulate_match(agentA, agentB, T, payoff_win = PAYOFF_WIN, payoff_loss = PAYOFF_LOSS)

    idx <- pos:(pos + T - 1L)
    a[idx] <- sim$a
    b[idx] <- sim$b
    roleA[idx] <- sim$roleA

    pos <- pos + T
  }

  list(
    S = S,
    T = T,
    a = a,
    b = b,
    roleA = roleA,
    start_idx = start_idx
  )
}

fit_wsls_policy <- function(data_list, stan_file, seed = 123) {

  mod <- compile_stan_model(stan_file)

  mod$sample(
    data = data_list,
    seed = seed,
    chains = STAN_CHAINS,
    iter_warmup = STAN_WARMUP,
    iter_sampling = STAN_SAMPLES,
    refresh = 200
  )
}
