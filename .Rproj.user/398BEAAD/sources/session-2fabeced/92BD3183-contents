# R/game.R
# -----------------------------------------------------------------------------
# Matching Pennies game mechanics + the "role swap" protocol.
#
# Roles:
# - Matcher: wants actions to be the same (match)
# - Mismatcher: wants actions to be different (mismatch)
#
# Protocol:
# - repeated game for T trials
# - at T/2 we swap roles for each player
#
# Output:
# - full action histories
# - per-trial win/loss and payoffs
# - summary totals + first/second half totals + swing
# -----------------------------------------------------------------------------

# Create the role vector for player A:
# 1 = Matcher in first half, 0 = Mismatcher in second half
make_roleA <- function(T) {
  half <- T / 2
  if (half != floor(half)) stop("T must be even for a clean half/half role swap.")
  c(rep(1L, half), rep(0L, half))
}

# Given A action, B action, and roleA, compute whether A wins (TRUE/FALSE)
# roleA = 1 (Matcher): A wins if a == b
# roleA = 0 (Mismatcher): A wins if a != b
winA_from <- function(a, b, roleA) {
  if (roleA == 1L) {
    return(a == b)
  } else {
    return(a != b)
  }
}

# Simulate a single repeated match between two agents.
# Agents must provide:
# - $choose(role, t): returns action 0/1
# - $update(opp_action, role, win, my_action): updates internal state
simulate_match <- function(agentA, agentB, T, payoff_win = 1, payoff_loss = -1) {

  roleA_vec <- make_roleA(T)
  roleB_vec <- 1L - roleA_vec  # opposite roles each trial

  a <- integer(T)
  b <- integer(T)
  winA <- logical(T)
  payoffA <- integer(T)

  for (t in seq_len(T)) {
    roleA <- roleA_vec[t]
    roleB <- roleB_vec[t]

    # Each agent chooses an action based on its strategy and internal state
    a[t] <- agentA$choose(role = roleA, t = t)
    b[t] <- agentB$choose(role = roleB, t = t)

    # Determine winner and payoffs (zero-sum)
    winA[t] <- winA_from(a[t], b[t], roleA)
    payoffA[t] <- if (winA[t]) payoff_win else payoff_loss

    # Update each agent with what happened this trial
    agentA$update(opp_action = b[t], role = roleA, win = winA[t], my_action = a[t])
    agentB$update(opp_action = a[t], role = roleB, win = !winA[t], my_action = b[t])
  }

  # Summaries
  half <- T / 2
  total_payoff <- sum(payoffA)
  payoff_first  <- sum(payoffA[1:half])
  payoff_second <- sum(payoffA[(half + 1):T])
  swing <- payoff_second - payoff_first

  # Win rate (sometimes easier to understand than +/- payoff)
  winrate <- mean(winA)

  list(
    T = T,
    roleA = roleA_vec,
    a = a,
    b = b,
    winA = winA,
    payoffA = payoffA,
    total_payoff = total_payoff,
    payoff_first = payoff_first,
    payoff_second = payoff_second,
    swing = swing,
    winrate = winrate
  )
}
